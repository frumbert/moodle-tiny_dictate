{"version":3,"file":"commands.min.js","sources":["../src/commands.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Recognise the speech and insert it into the editor.\n *\n * @module     tiny_dictate/commands\n * @copyright\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n *\n */\nimport {getButtonImage} from 'editor_tiny/utils';\nimport {get_string as getString} from 'core/str';\nimport {\n    component,\n    dictateButtonName,\n    icon,\n} from './common';\n\n// ==========================\n// Speech Recognition Engine\n// ==========================\n\nconst SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\nconst recognition = SpeechRecognition ? new SpeechRecognition() : null;\nlet recognizing = false;\n\nif (recognition) {\n    recognition.continuous = true;\n    recognition.interimResults = true;\n    recognition.lang = navigator.language;\n}\n\n/**\n * Handle the action for your plugin.\n * @param {TinyMCE.editor} editor The tinyMCE editor instance.\n * @param {TinyMCE.buttonApi} buttonApi Probably the tinyMCE buttonApi instance.\n */\nconst handleAction = (editor, buttonApi) => {\n\n    if (!recognition) {\n        return;\n    }\n\n    recognizing = !recognizing;\n\n    if (recognizing) {\n        recognition.start();\n        buttonApi.setActive(true);\n    } else {\n        recognition.stop();\n    }\n\n    recognition.onresult = (event) => {\n        let final_transcript = '';\n        for (let i = event.resultIndex; i < event.results.length; ++i) {\n            if (event.results[i].isFinal) {\n                final_transcript += event.results[i][0].transcript;\n            }\n        }\n        if (final_transcript) {\n            editor.insertContent(final_transcript);\n        }\n    };\n\n    recognition.onerror = (event) => {\n        window.console.log(event);\n    };\n\n    recognition.onend = () => {\n        if (recognizing) { // If recognition ends unexpectedly, restart it.\n            recognition.start();\n        } else {\n          buttonApi.setActive(false);\n        }\n    };\n};\n\nexport const getSetup = async() => {\n    const [\n        buttonTooltip,\n        buttonImage,\n    ] = await Promise.all([\n        getString('button_toggle_dictate', component),\n        getButtonImage('icon', component),\n    ]);\n\n    const SpeechRecognition =\n      window.SpeechRecognition || window.webkitSpeechRecognition;\n\n    return (editor) => {\n        if (SpeechRecognition) {\n\n          // Register the Moodle SVG as an icon suitable for use as a TinyMCE toolbar button.\n          editor.ui.registry.addIcon(icon, buttonImage.html);\n\n          // Register the Toolbar Button.\n          editor.ui.registry.addToggleButton(dictateButtonName, {\n              icon,\n              tooltip: buttonTooltip,\n              onAction: (buttonApi) => handleAction(editor, buttonApi),\n              onSetup: (buttonApi) => {\n                // When recognition ends, we need to update the button state.\n                if (recognition) {\n                    recognition.addEventListener('end', () => {\n                        buttonApi.setActive(false);\n                    });\n                }\n                return () => {}; // No cleanup needed\n              }\n          });\n\n        }\n    };\n};"],"names":["SpeechRecognition","window","webkitSpeechRecognition","recognition","recognizing","continuous","interimResults","lang","navigator","language","async","buttonTooltip","buttonImage","Promise","all","component","editor","ui","registry","addIcon","icon","html","addToggleButton","dictateButtonName","tooltip","onAction","buttonApi","start","setActive","stop","onresult","event","final_transcript","i","resultIndex","results","length","isFinal","transcript","insertContent","onerror","console","log","onend","handleAction","onSetup","addEventListener"],"mappings":";;;;;;;;;MAmCMA,kBAAoBC,OAAOD,mBAAqBC,OAAOC,wBACvDC,YAAcH,kBAAoB,IAAIA,kBAAsB,SAC9DI,aAAc,EAEdD,cACAA,YAAYE,YAAa,EACzBF,YAAYG,gBAAiB,EAC7BH,YAAYI,KAAOC,UAAUC,4BAgDTC,gBAEhBC,cACAC,mBACMC,QAAQC,IAAI,EAClB,mBAAU,2BAA4BC,oBACtC,yBAAe,OAAQA,qBAGrBf,kBACJC,OAAOD,mBAAqBC,OAAOC,+BAE7Bc,SACAhB,oBAGFgB,OAAOC,GAAGC,SAASC,QAAQC,aAAMR,YAAYS,MAG7CL,OAAOC,GAAGC,SAASI,gBAAgBC,6BAAsB,CACrDH,KAAAA,aACAI,QAASb,cACTc,SAAWC,WA9DJ,EAACV,OAAQU,aAErBvB,cAILC,aAAeA,YAEXA,aACAD,YAAYwB,QACZD,UAAUE,WAAU,IAEpBzB,YAAY0B,OAGhB1B,YAAY2B,SAAYC,YAChBC,iBAAmB,OAClB,IAAIC,EAAIF,MAAMG,YAAaD,EAAIF,MAAMI,QAAQC,SAAUH,EACpDF,MAAMI,QAAQF,GAAGI,UACjBL,kBAAoBD,MAAMI,QAAQF,GAAG,GAAGK,YAG5CN,kBACAhB,OAAOuB,cAAcP,mBAI7B7B,YAAYqC,QAAWT,QACnB9B,OAAOwC,QAAQC,IAAIX,QAGvB5B,YAAYwC,MAAQ,KACZvC,YACAD,YAAYwB,QAEdD,UAAUE,WAAU,MA2BSgB,CAAa5B,OAAQU,WAC9CmB,QAAUnB,YAEJvB,aACAA,YAAY2C,iBAAiB,OAAO,KAChCpB,UAAUE,WAAU,MAGrB"}